<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://unpkg.com/c3@0.7.18/c3.css" />
    <link href="./chart.css" rel="stylesheet" />
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/c3@0.7.18/c3.js"></script>
    <script src="./data/allAlgodata.js"></script>
    <script src="./data/insertionVsQuicksortData.js"></script>
    <script src="./data/quicksortInsertionData.js"></script>
    <script src="./data/quicksortData.js"></script>
    <script src="./data/kValueCalculations.js"></script>
    <script src="util.js"></script>
    <title>Sorting Algo Experiment</title>
  </head>
  <body>
    <h1>Sorting Algothrim Runtimes</h1>
    <p>
      <h3>Purpose:</h3> The goal of this experiment is to measure and compare the
      efficiency of sorting algorithms for sorting n elements. The algorithms
      that are examined are <a href="https://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a>, <a href="https://en.wikipedia.org/wiki/Quicksort">Randomized Quicksort</a>, Quicksort with Insertion 
      Sort Hybrid, and <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a>. This experiment will also determine which k value, the value in which the base case condition is met for quicksort so that insertion sort will sort the rest of the array, will provide the most efficient hybrid sorting algorithm when combining quicksort with insertion sort.
    </p>
    <p>
      <h3>Introduction:</h3>
      The running time of an algorithm on a particular input is the number of primitive operations or steps executed. An algorithm's running time depends on the input size that is given. The running time for the examined algorithms are expressed as the asymptotic time complexity, or big-O. The runtime of the algorithm is the actual measurement of the time the code takes to execute. The measurement of the runtimes of each algorithm for variable n as the array size can be quite representative of the running time of the algorithm. Proper measurement of the runtimes should show O(n<sup>2</sup>) for insertion sort, O(n log n) for quicksort, and O(n log n) for merge sort. 
    </p>
    <p>
      <h3>Hypothesis:</h3> Quicksort is more efficient than insertion sort for sorting large arrays given O(n<sup>2</sup>) for insertion sort and O(n log n) for quicksort. However, when implementing each sorting algorithm, quicksort has greater overhead than insertion sort and is less efficient than insertion sort for sorting smaller arrays. Quicksort combine with insertion sort would be the most efficient algorithm to sort larger size arrays.   
    </P>
    <p>
      <h3>Experimental Procedure:</h3> 
      <p>
      <b>Part I. Measure Runtime for All 4 Sorting Algothrims.</b>
      </p>
      The runtime of Merge Sort, Insertion Sort, Quicksort, and Quicksort with Insertion Sort (QuicksortInsertion and QuicksortInsertion2) algorithms where measured for sorting n elements, where 2<sup>1</sup> ≤ n ≤ 2<sup>20</sup>. There were 20 runtime measurements of each array size. Precision analysis was done for each array size by calculating the average and standard deviation of the runtimes in milliseconds. 
      <div class="batchCode">
        <pre class="singleCode">
          <code>
            /* INSERTION SORT **/

            function insertionSort(nums, lower = 0, upper = nums.length - 1) {
              for (let i = lower + 1; i <= upper; i++) {
                for (let j = i; j > lower && nums[j - 1] > nums[j]; j--) {
                  swap(nums, j, j - 1);
                }
              }
              return nums;
            }
          </code>
        </pre>
        <pre class="singleCode">
          <code>
            /* MERGE SORT **/

            function mergeSort(nums) {
              if (nums.length <= 1) {
                return nums;
              }
              // Split all the way
              let splitArrays = split(nums);
              let sortedA = mergeSort(splitArrays[0]);
              let sortedB = mergeSort(splitArrays[1]);
            
              // merge sorted (nums.length 0 and 1 are sorted)
              return merge(sortedA, sortedB);
            }
          </code>
        </pre>
      </div>
      <div class="batchCode">
        <pre class="singleCode">
          <code>
            /* QUICKSORT **/

            function quicksort(nums, lower, upper) {
              if (lower === undefined) {
                lower = 0;
              }
              if (upper === undefined) {
                upper = nums.length - 1;
              }
          
              if (lower >= upper) {
                return;
              }
            
              let p = randomizedPartition(nums, lower, upper);
            
              quicksort(nums, lower, p - 1);
              quicksort(nums, p + 1, upper);
            }
          </code>
        </pre>
        <pre class="singleCode">
          <code>
            /* QUICKSORT with INSERTION SORT HYBRID **/

            function quicksortInsertion(nums, k = 8, lower, upper) {
              if (lower === undefined) {
                lower = 0;
              }
              if (upper === undefined) {
                upper = nums.length - 1;
              }

              if (upper - lower <= k) {
                return insertionSort(nums, (lower = lower), (upper = upper));
              }
              let p = randomizedPartition(nums, lower, upper);
            
              quicksortInsertion(nums, k, lower, p - 1);
              quicksortInsertion(nums, k, p + 1, upper);
            }
          </code>
        </pre>
      </div>
      <pre class="singleBlockCode">
        <code>
          /* PARTITION AND RANDOMIZED PARTITION FOR QUICKSORT. **/

          function partition(nums, lower, upper) {
            let pivot = nums[upper];
            let i = lower - 1;
            for (let j = lower; j < upper; j++) {
              if (nums[j] <= pivot) {
                swap(nums, ++i, j);
              }
            }
            swap(nums, ++i, upper);
            return i;
          }
      
          function randomizedPartition(nums, lower, upper) {
            let i = Math.floor(Math.random() * (upper - lower + 1)) + lower;
            swap(nums, i, upper);
            return partition(nums, (lower = lower), (upper = upper));
          }
        </code>
      </pre>
      
      
      <p>
      <b>Part II. Determining k for Quicksort with Insertion Sort.</b>
      <p>
        To determine the size of the array (k) in which quicksort is faster than insertion sort. The runtime of insertion sort and quicksort algorithms where measured for sorting n elements, where 2<sup>2</sup> ≤ n ≤ 2<sup>10</sup>. There were 100,000 runtime measurements of each array size. The runtime for Quicksort with Insertion sort was measured, where 2<sup>3</sup> ≤ k ≤ 2<sup>8</sup> and 2<sup>2</sup> ≤ n ≤ 2<sup>22</sup>. Precision analysis was done for each array size and k by calculating the average and standard deviation of the runtimes in milliseconds. 
      </p>
      <p>All the codes were executed on a Mac laptop using OS X El Capitan, version 10.11.6 with a 2.7 GHz Intel Core i5 processor.</p>
    </p>
    <p>
      <h3>Results:</h3>
    </p>
    <p>The runtimes for each algorithm is plotted in a log/ log plot as shown in Graph 1. The slope for insertion sort is 2, which is consistant with O(nk). The slope for merge sort is 1, which is consistant with  O(nlog(n)). The slope for quicksort is also 1 with the constant less than the constant for merge sort. Quicksort and both variations of quicksort with insertion sort where k = 8 had the almost overlaying trend for increasing array size up to n = 2<sup>20</sup>.</p> In Graph 2, the runtimes of insertion sort and quicksort shows that insertion sort is more efficient than quicksort at sorting arrays that are smaller than approximately 103 elements. The k variable was calculated from the intersection point of insertion sort and quicksort to be approximately 103 elements.
    <p>
      <h4>Runtimes of Different Algothrims Sorting n Elements</h4>
    </p>
    <div>
      <div id="allAlgo"></div>
      <p class="caption">
      <b>Graph 1.</b> The average runtimes of the sorting algorithms for increasing array size in a log/ log plot. 
      </p>
    </div>
    <div>
      <p class="tableHeading">
        <b>Table 1.</b> The Average Runtimes and Standard Deviation of 4 Sorting Algothrims in Sorting Array Size (n).
      </p>
      <table id="allAlgoTable"></table>
    </div>
    <p>The average runtimes of insertion sort and quicksort was measured to determine the array size, k value, at which quicksort is more efficient than insertion sort.</p>
    <h4>Insertion Sort vs. Quicksort Runtimes for Small Array Size</h4>
    <div id="insertionVsQuicksort"></div>
    <p class="caption">
      <b>Graph 2.</b> The average runtimes for insertion sort and quicksort in log/ log plot. The k value, or the intersecting point, is at approximately 103.46 elements. 
    </p>
    <div>
      <p class="tableHeading">
        <b>Table 2:</b> The Average Runtimes and Standard Deviation of Quicksort and Insertion Sort in Sorting Small Array Sizes. 
      </p>
      <table id="insertionVquicksortTable"></table>
    </div>
    <div>
      <h4>k value Comparison for Quicksort with Insertion Sort Hybrid.</h4>
      <div id="quicksortInsertion"></div>
      <p class="caption">
        <b>Graph 3.</b> The average runtimes for quicksort with insertion sort at various k values where k is between 2<sup>3</sup> and 2<sup>8</sup>. 
      </p>
    </div>
    <h4>Quicksort vs. Quicksort Insertion Hybrid Runtimes</h4>
    <div class="comparisonCharts">
      <div class="item_chart">
        <h4>k = 8</h4>
        <div id="quicksort8"></div>
        <p class="subgraphLabel">
         <i>(a)</i>
        </p>
      </div>
      <div class="item_chart">
        <h4>k = 103</h4>
        <div id="quicksort103"></div>
        <p class="subgraphLabel">
          <i>(b)</i>
        </p>
      </div>
    </div>
    <p class="caption">
      <b>Graph 4a-b. </b> The average runtimes for quicksort verus quicksort with insertion sort hybrid where a) k = 8 and b) k = 103 for array sizes between 2<sup>2</sup> and 2<sup>26</sup>.
     </p>
      <h3>Discussion:</h3>
      <p>The trend in the runtime measurements for each sorting algorithm at increasing array size, n, were consistant with the expected big-O of the algorithms. Insertion sort is not an efficient algorithm for sorting large size arrays as the runtime will increase by a factor of 4 each time the array size doubles.  </p>
      <p class="tableHeading"><b>Table 3:</b> Simple Computation of the Cost of Insertion Sort and Quicksort at Different Constants.</p>
      <table id="kTable"></table>
      <div id="kCalculation"></div>
    </div>
    <script src="./index.js"></script>
  </body>
</html>
